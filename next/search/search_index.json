{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Freqenz Pylint Datetime Library","text":""},{"location":"#introduction","title":"Introduction","text":"<p>checker to ensure correct datetime usage with aware objects in datetime module</p> <p>TODO(cookiecutter): Improve the README file</p>"},{"location":"#contributing","title":"Contributing","text":"<p>If you want to know how to build this project and contribute to it, please check out the Contributing Guide.</p>"},{"location":"CONTRIBUTING/","title":"Contributing to Freqenz Pylint Datetime Library","text":""},{"location":"CONTRIBUTING/#build","title":"Build","text":"<p>You can use <code>build</code> to simply build the source and binary distribution:</p> <pre><code>python -m pip install build\npython -m build\n</code></pre>"},{"location":"CONTRIBUTING/#local-development","title":"Local development","text":"<p>You can use editable installs to develop the project locally (it will install all the dependencies too):</p> <pre><code>python -m pip install -e .\n</code></pre> <p>Or you can install all development dependencies (<code>mypy</code>, <code>pylint</code>, <code>pytest</code>, etc.) in one go too: <pre><code>python -m pip install -e .[dev]\n</code></pre></p> <p>If you don't want to install all the dependencies, you can also use <code>nox</code> to run the tests and other checks creating its own virtual environments:</p> <pre><code>python -m pip install .[dev-noxfile]\nnox\n</code></pre> <p>You can also use <code>nox -R</code> to reuse the current testing environment to speed up test at the expense of a higher chance to end up with a dirty test environment.</p>"},{"location":"CONTRIBUTING/#running-tests-checks-individually","title":"Running tests / checks individually","text":"<p>For a better development test cycle you can install the runtime and test dependencies and run <code>pytest</code> manually.</p> <pre><code>python -m pip install .[dev-pytest]  # included in .[dev] too\n# And for example\npytest tests/test_*.py\n</code></pre> <p>Or you can use <code>nox</code>:</p> <pre><code>nox -R -s pytest -- test/test_*.py\n</code></pre> <p>The same appliest to <code>pylint</code> or <code>mypy</code> for example:</p> <pre><code>nox -R -s pylint -- test/test_*.py\nnox -R -s mypy -- test/test_*.py\n</code></pre>"},{"location":"CONTRIBUTING/#building-the-documentation","title":"Building the documentation","text":"<p>To build the documentation, first install the dependencies (if you didn't install all <code>dev</code> dependencies):</p> <pre><code>python -m pip install -e .[dev-mkdocs]\n</code></pre> <p>Then you can build the documentation (it will be written in the <code>site/</code> directory):</p> <pre><code>mkdocs build\n</code></pre> <p>Or you can just serve the documentation without building it using:</p> <pre><code>mkdocs serve\n</code></pre> <p>Your site will be updated live when you change your files (provided that you used <code>pip install -e .</code>, beware of a common pitfall of using <code>pip install</code> without <code>-e</code>, in that case the API reference won't change unless you do a new <code>pip install</code>).</p> <p>To build multi-version documentation, we use mike. If you want to see how the multi-version sites looks like locally, you can use:</p> <pre><code>mike deploy my-version\nmike set-default my-version\nmike serve\n</code></pre> <p><code>mike</code> works in mysterious ways. Some basic information:</p> <ul> <li><code>mike deploy</code> will do a <code>mike build</code> and write the results to your local <code>gh-pages</code> branch. <code>my-version</code> is an arbitrary name for the local version   you want to preview.</li> <li><code>mike set-default</code> is needed so when you serve the documentation, it goes to   your newly produced documentation by default.</li> <li><code>mike serve</code> will serve the contents of your local <code>gh-pages</code> branch. Be   aware that, unlike <code>mkdocs serve</code>, changes to the sources won't be shown   live, as the <code>mike deploy</code> step is needed to refresh them.</li> </ul> <p>Be careful not to use <code>--push</code> with <code>mike deploy</code>, otherwise it will push your local <code>gh-pages</code> branch to the <code>origin</code> remote.</p> <p>That said, if you want to test the actual website in your fork, you can always use <code>mike deploy --push --remote your-fork-remote</code>, and then access the GitHub pages produced for your fork.</p>"},{"location":"CONTRIBUTING/#releasing","title":"Releasing","text":"<p>These are the steps to create a new release:</p> <ol> <li> <p>Get the latest head you want to create a release from.</p> </li> <li> <p>Update the <code>RELEASE_NOTES.md</code> file if it is not complete, up to date, and    remove template comments (<code>&lt;!-- ... -&gt;</code>) and empty sections. Submit a pull    request if an update is needed, wait until it is merged, and update the    latest head you want to create a release from to get the new merged pull    request.</p> </li> <li> <p>Create a new signed tag using the release notes and    a semver compatible version number with a <code>v</code> prefix,    for example:</p> </li> </ol> <pre><code>git tag -s --cleanup=whitespace -F RELEASE_NOTES.md v0.0.1\n</code></pre> <ol> <li> <p>Push the new tag.</p> </li> <li> <p>A GitHub action will test the tag and if all goes well it will create    a GitHub    Release,    and upload a new package to    PyPI    automatically.</p> </li> <li> <p>Once this is done, reset the <code>RELEASE_NOTES.md</code> with the template:</p> </li> </ol> <pre><code>cp .github/RELEASE_NOTES.template.md RELEASE_NOTES.md\n</code></pre> <p>Commit the new release notes and create a PR (this step should be automated    eventually too).</p> <ol> <li>Celebrate!</li> </ol>"},{"location":"SUMMARY/","title":"SUMMARY","text":"<ul> <li>Home</li> <li>API Reference</li> <li>Contributing</li> </ul>"},{"location":"reference/SUMMARY/","title":"SUMMARY","text":"<ul> <li>frequenz<ul> <li>lib<ul> <li>datetime_time_checker</li> </ul> </li> <li>pylint_datetime</li> </ul> </li> </ul>"},{"location":"reference/frequenz/lib/datetime_time_checker/","title":"datetime_time_checker","text":""},{"location":"reference/frequenz/lib/datetime_time_checker/#frequenz.lib.datetime_time_checker","title":"<code>frequenz.lib.datetime_time_checker</code>","text":"<p>Pylint checker ensure correct usage of datetime module, especially around aware/naive objects.</p>"},{"location":"reference/frequenz/lib/datetime_time_checker/#frequenz.lib.datetime_time_checker-classes","title":"Classes","text":""},{"location":"reference/frequenz/lib/datetime_time_checker/#frequenz.lib.datetime_time_checker.DatetimeChecker","title":"<code>frequenz.lib.datetime_time_checker.DatetimeChecker</code>","text":"<p>             Bases: <code>BaseChecker</code></p> <p>class for custom pylint checker.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/lib/datetime_time_checker.py</code> <pre><code>class DatetimeChecker(BaseChecker):\n\"\"\"class for custom pylint checker.\"\"\"\n__implements__ = IAstroidChecker\nname = \"pylint-datetime\"\npriority = -1\nmsgs = {\n\"W9999\": (\n\"timedelta() called without keyword arguments\",\n\"timedelta-no-keyword-args\",\n\"timedelta() called without keyword arguments.\",\n),\n\"W9998\": (\n'Function call to \"%s\" should be called with a timezone argument',\n\"timezone-no-argument\",\n'Function call to \"%s\" should be called with a timezone argument',\n),\n\"W9997\": (\n'Function call to \"%s\" can only produce naive objects',\n\"naive-datetime-call\",\n'Function call to \"%s\" can only produce naive objects, aware objects necessary',\n),\n\"W9996\": (\n'Attribute access \"%s\" should be followed by a call to replace with timezone argument',\n\"naive-datetime-no-timezone\",\n'Attribute access \"%s\" should be followed by a call to replace with timezone argument',\n),\n\"W9995\": (\n'Function call \"%s\" should be followed by a call to replace with timezone argument',\n\"naive-datetime-call-no-timezone\",\n'Function call \"%s\" should be followed by a call to replace with timezone argument',\n),\n}\ndef __init__(self, linter: pylint.lint.PyLinter=None) -&gt; None:\n\"\"\"Initialize checker.\n        Args:\n            linter: instance of pylint linter.\n        \"\"\"\nsuper().__init__(linter)\ndef timedelta_with_keywords(self, node: astroid.node_classes.NodeNG, name: str) -&gt; None:\n\"\"\"Check calls to timedelta() and datetime.timedelta() for keyword arguments.\n        Args:\n            node: the node that visit_call originates from.\n            name: name of the function being called.\n        \"\"\"\nif name == \"timedelta\":\nfor _ in node.args:\nself.add_message(\"timedelta-no-keyword-args\", node=node)\nif not node.args and not node.keywords:\nself.add_message(\"timedelta-no-keyword-args\", node=node)\n# check for positional arguments cheesy, uses fact, that they have one Attribute Argument.\ndef timezone_argument(self, node: astroid.node_classes.NodeNG, name: str) -&gt; None:\n\"\"\"Check calls to datetime, now, fromtimestamp, astimezone and time for timezone arg.\n        Args:\n            node: the node that visit_call originates from.\n            name: name of the function being called.\n        \"\"\"\nif name in (\"datetime\", \"now\", \"fromtimestamp\", \"astimezone\", \"time\"):\nif not any(\nisinstance(arg, astroid.Keyword) and arg.arg in (\"tz\", \"tzinfo\")\nfor arg in node.keywords\n):\nif not any(isinstance(arg, astroid.Attribute) for arg in node.args):\nself.add_message(\"timezone-no-argument\", node=node, args=(name,))\ndef naive_functions(self, node: astroid.node_classes.NodeNG, name: str) -&gt; None:\n\"\"\"Check that functions producing only naive objects are never called.\n        Args:\n            node: the node that visit_call originates from\n            name: name of the function being called\n        \"\"\"\nif name in (\"today\", \"utcnow\", \"utcfromtimestamp\", \"utctimetuple\", \"time\"):\nself.add_message(\"naive-datetime-call\", node=node, args=(name,))\ndef visit_call(self, node: astroid.node_classes.NodeNG) -&gt; None:\n\"\"\"Pylint function responds when any function is called.\n        Args:\n            node: origin node for function call.\n        \"\"\"\nif hasattr(node.func, \"name\"):\nname = node.func.name\nelif hasattr(node.func, \"attrname\"):\nname = node.func.attrname\nself.timedelta_with_keywords(node, name)\nself.timezone_argument(node, name)\nself.naive_functions(node, name)\ndef naive_properties_methods_replace(\nself, node: astroid.node_classes.NodeNG, assigned_value: Any, assigned_var: Any\n) -&gt; None:\n\"\"\"Check for a replace call specifiying timezone after naive property or function.\n        Args:\n            node: the node that visit_call originates from.\n            assigned_value: the value of the assignment that triggered function call.\n            assigned_var: the variable that the value was assigned to.\n        \"\"\"\nnext_node = assigned_var\nnext_is_empty = True\nif next_node and next_node.next_sibling():\nnext_is_empty = False\nnext_node = next_node.next_sibling()\nif (\nisinstance(next_node.value, astroid.Call)\nand isinstance(next_node.value.func, astroid.Attribute)\nand next_node.value.func.attrname == \"replace\"\n):\nif not any(\nisinstance(arg, astroid.Keyword) and arg.arg == \"tzinfo\"\nfor arg in next_node.value.keywords\n) and (\nnot any(\nisinstance(arg, astroid.Attribute)\nfor arg in next_node.value.args\n)\n):\nnew_node = next_node.value\nself.add_message(\n\"timezone-no-argument\", node=new_node, args=(assigned_value,)\n)\nelse:\nself.add_message(\n\"naive-datetime-no-timezone\", node=node, args=(assigned_value,)\n)\nif next_is_empty:\nself.add_message(\n\"naive-datetime-no-timezone\", node=node, args=(assigned_value,)\n)\ndef visit_assign(self, node: astroid.node_classes.NodeNG) -&gt; None:\n\"\"\"Pylint function responds when any assignment takes place.\n        Args:\n            node: the node that visit_call originates from.\n        \"\"\"\nassigned_var = node.targets[0]\nassigned_value = node.value\nif isinstance(assigned_var, astroid.AssignName):\nassigned_var_type = assigned_var.inferred()[0]\nif assigned_var_type.qname() in (\"datetime.datetime\", \"datetime.time\"):\nif isinstance(assigned_value, astroid.Attribute):\nif assigned_value.attrname in (\"min\", \"max\"):\nass_val_name = assigned_value.attrname\nself.naive_properties_methods_replace(\nnode, ass_val_name, assigned_var\n)\nif isinstance(assigned_value, astroid.Call):\nif assigned_value.func.attrname in (\n\"fromordinal\",\n\"fromisocalendar\",\n):\nass_val_name = assigned_value.func.attrname\nself.naive_properties_methods_replace(\nnode, ass_val_name, assigned_var\n)\n</code></pre>"},{"location":"reference/frequenz/lib/datetime_time_checker/#frequenz.lib.datetime_time_checker.DatetimeChecker-functions","title":"Functions","text":""},{"location":"reference/frequenz/lib/datetime_time_checker/#frequenz.lib.datetime_time_checker.DatetimeChecker.__init__","title":"<code>__init__(linter=None)</code>","text":"<p>Initialize checker.</p> PARAMETER  DESCRIPTION <code>linter</code> <p>instance of pylint linter.</p> <p> TYPE: <code>pylint.lint.PyLinter</code> DEFAULT: <code>None</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/lib/datetime_time_checker.py</code> <pre><code>def __init__(self, linter: pylint.lint.PyLinter=None) -&gt; None:\n\"\"\"Initialize checker.\n    Args:\n        linter: instance of pylint linter.\n    \"\"\"\nsuper().__init__(linter)\n</code></pre>"},{"location":"reference/frequenz/lib/datetime_time_checker/#frequenz.lib.datetime_time_checker.DatetimeChecker.naive_functions","title":"<code>naive_functions(node, name)</code>","text":"<p>Check that functions producing only naive objects are never called.</p> PARAMETER  DESCRIPTION <code>node</code> <p>the node that visit_call originates from</p> <p> TYPE: <code>astroid.node_classes.NodeNG</code> </p> <code>name</code> <p>name of the function being called</p> <p> TYPE: <code>str</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/lib/datetime_time_checker.py</code> <pre><code>def naive_functions(self, node: astroid.node_classes.NodeNG, name: str) -&gt; None:\n\"\"\"Check that functions producing only naive objects are never called.\n    Args:\n        node: the node that visit_call originates from\n        name: name of the function being called\n    \"\"\"\nif name in (\"today\", \"utcnow\", \"utcfromtimestamp\", \"utctimetuple\", \"time\"):\nself.add_message(\"naive-datetime-call\", node=node, args=(name,))\n</code></pre>"},{"location":"reference/frequenz/lib/datetime_time_checker/#frequenz.lib.datetime_time_checker.DatetimeChecker.naive_properties_methods_replace","title":"<code>naive_properties_methods_replace(node, assigned_value, assigned_var)</code>","text":"<p>Check for a replace call specifiying timezone after naive property or function.</p> PARAMETER  DESCRIPTION <code>node</code> <p>the node that visit_call originates from.</p> <p> TYPE: <code>astroid.node_classes.NodeNG</code> </p> <code>assigned_value</code> <p>the value of the assignment that triggered function call.</p> <p> TYPE: <code>Any</code> </p> <code>assigned_var</code> <p>the variable that the value was assigned to.</p> <p> TYPE: <code>Any</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/lib/datetime_time_checker.py</code> <pre><code>def naive_properties_methods_replace(\nself, node: astroid.node_classes.NodeNG, assigned_value: Any, assigned_var: Any\n) -&gt; None:\n\"\"\"Check for a replace call specifiying timezone after naive property or function.\n    Args:\n        node: the node that visit_call originates from.\n        assigned_value: the value of the assignment that triggered function call.\n        assigned_var: the variable that the value was assigned to.\n    \"\"\"\nnext_node = assigned_var\nnext_is_empty = True\nif next_node and next_node.next_sibling():\nnext_is_empty = False\nnext_node = next_node.next_sibling()\nif (\nisinstance(next_node.value, astroid.Call)\nand isinstance(next_node.value.func, astroid.Attribute)\nand next_node.value.func.attrname == \"replace\"\n):\nif not any(\nisinstance(arg, astroid.Keyword) and arg.arg == \"tzinfo\"\nfor arg in next_node.value.keywords\n) and (\nnot any(\nisinstance(arg, astroid.Attribute)\nfor arg in next_node.value.args\n)\n):\nnew_node = next_node.value\nself.add_message(\n\"timezone-no-argument\", node=new_node, args=(assigned_value,)\n)\nelse:\nself.add_message(\n\"naive-datetime-no-timezone\", node=node, args=(assigned_value,)\n)\nif next_is_empty:\nself.add_message(\n\"naive-datetime-no-timezone\", node=node, args=(assigned_value,)\n)\n</code></pre>"},{"location":"reference/frequenz/lib/datetime_time_checker/#frequenz.lib.datetime_time_checker.DatetimeChecker.timedelta_with_keywords","title":"<code>timedelta_with_keywords(node, name)</code>","text":"<p>Check calls to timedelta() and datetime.timedelta() for keyword arguments.</p> PARAMETER  DESCRIPTION <code>node</code> <p>the node that visit_call originates from.</p> <p> TYPE: <code>astroid.node_classes.NodeNG</code> </p> <code>name</code> <p>name of the function being called.</p> <p> TYPE: <code>str</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/lib/datetime_time_checker.py</code> <pre><code>def timedelta_with_keywords(self, node: astroid.node_classes.NodeNG, name: str) -&gt; None:\n\"\"\"Check calls to timedelta() and datetime.timedelta() for keyword arguments.\n    Args:\n        node: the node that visit_call originates from.\n        name: name of the function being called.\n    \"\"\"\nif name == \"timedelta\":\nfor _ in node.args:\nself.add_message(\"timedelta-no-keyword-args\", node=node)\nif not node.args and not node.keywords:\nself.add_message(\"timedelta-no-keyword-args\", node=node)\n</code></pre>"},{"location":"reference/frequenz/lib/datetime_time_checker/#frequenz.lib.datetime_time_checker.DatetimeChecker.timezone_argument","title":"<code>timezone_argument(node, name)</code>","text":"<p>Check calls to datetime, now, fromtimestamp, astimezone and time for timezone arg.</p> PARAMETER  DESCRIPTION <code>node</code> <p>the node that visit_call originates from.</p> <p> TYPE: <code>astroid.node_classes.NodeNG</code> </p> <code>name</code> <p>name of the function being called.</p> <p> TYPE: <code>str</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/lib/datetime_time_checker.py</code> <pre><code>def timezone_argument(self, node: astroid.node_classes.NodeNG, name: str) -&gt; None:\n\"\"\"Check calls to datetime, now, fromtimestamp, astimezone and time for timezone arg.\n    Args:\n        node: the node that visit_call originates from.\n        name: name of the function being called.\n    \"\"\"\nif name in (\"datetime\", \"now\", \"fromtimestamp\", \"astimezone\", \"time\"):\nif not any(\nisinstance(arg, astroid.Keyword) and arg.arg in (\"tz\", \"tzinfo\")\nfor arg in node.keywords\n):\nif not any(isinstance(arg, astroid.Attribute) for arg in node.args):\nself.add_message(\"timezone-no-argument\", node=node, args=(name,))\n</code></pre>"},{"location":"reference/frequenz/lib/datetime_time_checker/#frequenz.lib.datetime_time_checker.DatetimeChecker.visit_assign","title":"<code>visit_assign(node)</code>","text":"<p>Pylint function responds when any assignment takes place.</p> PARAMETER  DESCRIPTION <code>node</code> <p>the node that visit_call originates from.</p> <p> TYPE: <code>astroid.node_classes.NodeNG</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/lib/datetime_time_checker.py</code> <pre><code>def visit_assign(self, node: astroid.node_classes.NodeNG) -&gt; None:\n\"\"\"Pylint function responds when any assignment takes place.\n    Args:\n        node: the node that visit_call originates from.\n    \"\"\"\nassigned_var = node.targets[0]\nassigned_value = node.value\nif isinstance(assigned_var, astroid.AssignName):\nassigned_var_type = assigned_var.inferred()[0]\nif assigned_var_type.qname() in (\"datetime.datetime\", \"datetime.time\"):\nif isinstance(assigned_value, astroid.Attribute):\nif assigned_value.attrname in (\"min\", \"max\"):\nass_val_name = assigned_value.attrname\nself.naive_properties_methods_replace(\nnode, ass_val_name, assigned_var\n)\nif isinstance(assigned_value, astroid.Call):\nif assigned_value.func.attrname in (\n\"fromordinal\",\n\"fromisocalendar\",\n):\nass_val_name = assigned_value.func.attrname\nself.naive_properties_methods_replace(\nnode, ass_val_name, assigned_var\n)\n</code></pre>"},{"location":"reference/frequenz/lib/datetime_time_checker/#frequenz.lib.datetime_time_checker.DatetimeChecker.visit_call","title":"<code>visit_call(node)</code>","text":"<p>Pylint function responds when any function is called.</p> PARAMETER  DESCRIPTION <code>node</code> <p>origin node for function call.</p> <p> TYPE: <code>astroid.node_classes.NodeNG</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/lib/datetime_time_checker.py</code> <pre><code>def visit_call(self, node: astroid.node_classes.NodeNG) -&gt; None:\n\"\"\"Pylint function responds when any function is called.\n    Args:\n        node: origin node for function call.\n    \"\"\"\nif hasattr(node.func, \"name\"):\nname = node.func.name\nelif hasattr(node.func, \"attrname\"):\nname = node.func.attrname\nself.timedelta_with_keywords(node, name)\nself.timezone_argument(node, name)\nself.naive_functions(node, name)\n</code></pre>"},{"location":"reference/frequenz/lib/datetime_time_checker/#frequenz.lib.datetime_time_checker-functions","title":"Functions","text":""},{"location":"reference/frequenz/lib/datetime_time_checker/#frequenz.lib.datetime_time_checker.register","title":"<code>frequenz.lib.datetime_time_checker.register(linter)</code>","text":"<p>Pylint function to register checker.</p> PARAMETER  DESCRIPTION <code>linter</code> <p>instance of pylint linter.</p> <p> TYPE: <code>pylint.lint.PyLinter</code> </p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/lib/datetime_time_checker.py</code> <pre><code>def register(linter: pylint.lint.PyLinter) -&gt; None:\n\"\"\"Pylint function to register checker.\n    Args:\n        linter: instance of pylint linter.\n    \"\"\"\nlinter.register_checker(DatetimeChecker(linter))\n</code></pre>"},{"location":"reference/frequenz/pylint_datetime/","title":"pylint_datetime","text":""},{"location":"reference/frequenz/pylint_datetime/#frequenz.pylint_datetime","title":"<code>frequenz.pylint_datetime</code>","text":"<p>checker to ensure correct datetime usage with aware objects in datetime module.</p> <p>TODO(cookiecutter): Add a more descriptive module description.</p>"},{"location":"reference/frequenz/pylint_datetime/#frequenz.pylint_datetime-functions","title":"Functions","text":""},{"location":"reference/frequenz/pylint_datetime/#frequenz.pylint_datetime.delete_me","title":"<code>frequenz.pylint_datetime.delete_me(*, blow_up=False)</code>","text":"<p>Do stuff for demonstration purposes.</p> PARAMETER  DESCRIPTION <code>blow_up</code> <p>If True, raise an exception.</p> <p> TYPE: <code>bool</code> DEFAULT: <code>False</code> </p> RETURNS DESCRIPTION <code>bool</code> <p>True if no exception was raised.</p> RAISES DESCRIPTION <code>RuntimeError</code> <p>if blow_up is True.</p> Source code in <code>/opt/hostedtoolcache/Python/3.11.4/x64/lib/python3.11/site-packages/frequenz/pylint_datetime/__init__.py</code> <pre><code>def delete_me(*, blow_up: bool = False) -&gt; bool:\n\"\"\"Do stuff for demonstration purposes.\n    Args:\n        blow_up: If True, raise an exception.\n    Returns:\n        True if no exception was raised.\n    Raises:\n        RuntimeError: if blow_up is True.\n    \"\"\"\nif blow_up:\nraise RuntimeError(\"This function should be removed!\")\nreturn True\n</code></pre>"}]}